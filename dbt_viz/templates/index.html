<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dbt Model Lineage</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #graph {
            flex: 1;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #search {
            padding: 10px 15px;
            border: 1px solid #3a3a5c;
            border-radius: 8px;
            background: #252542;
            color: #eee;
            font-size: 14px;
            width: 250px;
            outline: none;
        }

        #search:focus {
            border-color: #6c63ff;
        }

        #search::placeholder {
            color: #888;
        }

        .zoom-controls {
            display: flex;
            gap: 5px;
        }

        .zoom-btn, .action-btn {
            height: 36px;
            padding: 0 12px;
            border: 1px solid #3a3a5c;
            border-radius: 8px;
            background: #252542;
            color: #eee;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .zoom-btn {
            width: 36px;
            font-size: 18px;
            padding: 0;
        }

        .zoom-btn:hover, .action-btn:hover {
            background: #3a3a5c;
        }

        #legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: #252542;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #3a3a5c;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        #panel-resizer {
            width: 6px;
            background: #3a3a5c;
            cursor: col-resize;
            display: none;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        #panel-resizer:hover,
        #panel-resizer.active {
            background: #6c63ff;
        }

        #panel-resizer.visible {
            display: block;
        }

        #details-panel {
            width: 400px;
            min-width: 250px;
            max-width: 800px;
            background: #252542;
            border-left: 1px solid #3a3a5c;
            padding: 20px;
            overflow-y: auto;
            display: none;
            flex-shrink: 0;
        }

        #details-panel.visible {
            display: flex;
            flex-direction: column;
        }

        #details-panel h2 {
            font-size: 18px;
            margin-bottom: 5px;
            color: #fff;
        }

        #details-panel .resource-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 15px;
        }

        #details-panel .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
        }

        #details-panel .close-btn:hover {
            color: #fff;
        }

        #details-content {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .detail-section {
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .detail-section.resizable {
            display: flex;
            flex-direction: column;
            min-height: 100px;
        }

        .detail-section h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }

        .detail-section p {
            font-size: 14px;
            line-height: 1.5;
            color: #ccc;
        }

        .section-resizer {
            height: 8px;
            background: transparent;
            cursor: row-resize;
            flex-shrink: 0;
            margin: 8px 0;
            position: relative;
        }

        .section-resizer::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 4px;
            background: #3a3a5c;
            border-radius: 2px;
            transition: background 0.2s;
        }

        .section-resizer:hover::before,
        .section-resizer.active::before {
            background: #6c63ff;
        }

        .detail-section .value {
            font-family: 'SF Mono', Monaco, monospace;
            background: #1a1a2e;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 13px;
        }

        .columns-list {
            height: 200px;
            min-height: 80px;
            max-height: 600px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .column-item {
            padding: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .column-name {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
            color: #6c63ff;
        }

        .column-type {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            color: #888;
            background: #2a2a4a;
            padding: 2px 6px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .column-desc {
            font-size: 12px;
            color: #888;
            margin-top: 3px;
        }

        .column-badges {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .column-transform {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: 500;
        }

        .transform-passthrough {
            background: #2a4a3a;
            color: #4ade80;
        }

        .transform-rename {
            background: #4a3a2a;
            color: #fbbf24;
        }

        .transform-derived {
            background: #3a2a4a;
            color: #a78bfa;
        }

        .transform-aggregated {
            background: #4a2a3a;
            color: #f472b6;
        }

        .transform-literal {
            background: #3a3a4a;
            color: #94a3b8;
        }

        .transform-windowed {
            background: #2a3a4a;
            color: #38bdf8;
        }

        .column-sources {
            margin-top: 6px;
            font-size: 11px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }

        .sources-label {
            color: #666;
        }

        .source-ref {
            background: #1a2a3a;
            color: #60a5fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'SF Mono', Monaco, monospace;
            cursor: help;
        }

        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .tag {
            background: #3a3a5c;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .sql-preview {
            background: #1a1a2e;
            padding: 12px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            height: 200px;
            min-height: 80px;
            max-height: 600px;
            overflow: auto;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
            flex-shrink: 0;
        }

        .sql-warning {
            background: #4a3a2a;
            color: #fbbf24;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 12px;
            border-left: 4px solid #fbbf24;
            font-size: 13px;
        }

        .sql-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            border-bottom: 1px solid #2a2a3e;
        }

        .sql-tab {
            background: transparent;
            border: none;
            color: #888;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .sql-tab:hover {
            color: #aaa;
        }

        .sql-tab.active {
            color: #6c63ff;
            border-bottom-color: #6c63ff;
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
        }

        .node rect {
            stroke-width: 2;
            transition: stroke-width 0.2s;
        }

        .node.highlighted rect {
            stroke-width: 4;
        }

        .node.dimmed {
            opacity: 0.2;
        }

        .node.hidden {
            display: none;
        }

        .node text {
            font-size: 12px;
            fill: #fff;
            pointer-events: none;
        }

        .node .node-type {
            font-size: 9px;
            fill: rgba(255,255,255,0.7);
            text-transform: uppercase;
        }

        .node.dimmed text {
            opacity: 0.3;
        }

        .link {
            stroke: #4a4a6c;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .link.highlighted {
            stroke: #6c63ff;
            stroke-width: 3;
        }

        .link.dimmed {
            opacity: 0.1;
        }

        .link.hidden {
            display: none;
        }

        #arrowhead {
            fill: #4a4a6c;
        }

        #arrowhead.highlighted {
            fill: #6c63ff;
        }

        /* Context menu */
        #context-menu {
            position: fixed;
            background: #252542;
            border: 1px solid #3a3a5c;
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        #context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-menu-item:hover {
            background: #3a3a5c;
        }

        .context-menu-item.disabled {
            opacity: 0.4;
            pointer-events: none;
        }

        .context-menu-divider {
            height: 1px;
            background: #3a3a5c;
            margin: 8px 0;
        }

        .context-menu-icon {
            width: 16px;
            text-align: center;
        }

        /* Collapse indicators */
        .collapse-indicator {
            cursor: pointer;
            transition: transform 0.2s;
        }

        .collapse-indicator:hover {
            transform: scale(1.2);
        }

        .collapse-indicator circle {
            fill: #3a3a5c;
            stroke: #5a5a7c;
            stroke-width: 1;
        }

        .collapse-indicator text {
            fill: #fff;
            font-size: 10px;
            font-weight: bold;
        }

        /* Hidden count badge */
        .hidden-badge {
            position: absolute;
            top: 60px;
            right: 20px;
            background: #252542;
            border: 1px solid #3a3a5c;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 13px;
            display: none;
        }

        .hidden-badge.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="graph">
            <div id="controls">
                <input type="text" id="search" placeholder="Search models...">
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-in">+</button>
                    <button class="zoom-btn" id="zoom-out">−</button>
                    <button class="zoom-btn" id="zoom-reset">⟲</button>
                </div>
                <button class="action-btn" id="expand-all">Expand All</button>
            </div>
            <div id="hidden-badge" class="hidden-badge"></div>
            <div id="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #6c63ff;"></div>
                    <span>Model</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00c9a7;"></div>
                    <span>Source</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffc75f;"></div>
                    <span>Seed</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>Snapshot</span>
                </div>
                <div class="legend-item" style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #3a3a5c;">
                    <span style="font-size: 11px; color: #888;">Right-click node to collapse/expand</span>
                </div>
            </div>
            <svg></svg>
        </div>
        <div id="panel-resizer"></div>
        <div id="details-panel">
            <button class="close-btn" id="close-details">&times;</button>
            <div id="details-content"></div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-menu-item" id="ctx-collapse-upstream">
            <span class="context-menu-icon">◀</span>
            <span>Collapse Upstream</span>
        </div>
        <div class="context-menu-item" id="ctx-collapse-downstream">
            <span class="context-menu-icon">▶</span>
            <span>Collapse Downstream</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" id="ctx-expand-upstream">
            <span class="context-menu-icon">◀</span>
            <span>Expand Upstream</span>
        </div>
        <div class="context-menu-item" id="ctx-expand-downstream">
            <span class="context-menu-icon">▶</span>
            <span>Expand Downstream</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" id="ctx-focus">
            <span class="context-menu-icon">◎</span>
            <span>Focus on This</span>
        </div>
    </div>

    <script>
        // Colors for different resource types
        const colors = {
            model: '#6c63ff',
            source: '#00c9a7',
            seed: '#ffc75f',
            snapshot: '#ff6b6b'
        };

        // Load data and initialize
        fetch('/data.json')
            .then(response => response.json())
            .then(data => initGraph(data))
            .catch(error => console.error('Error loading data:', error));

        function initGraph(data) {
            const svg = d3.select('svg');
            const container = document.getElementById('graph');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Hidden nodes tracking
            const hiddenNodes = new Set();
            let contextMenuNode = null;

            // Create arrow marker
            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '-0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('orient', 'auto')
                .attr('markerWidth', 8)
                .attr('markerHeight', 8)
                .append('path')
                .attr('d', 'M 0,-4 L 8,0 L 0,4')
                .attr('fill', '#4a4a6c');

            // Create main group for zoom/pan
            const g = svg.append('g');

            // Set up zoom
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1.3);
            });
            document.getElementById('zoom-out').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 0.7);
            });
            document.getElementById('zoom-reset').addEventListener('click', () => {
                svg.transition().call(zoom.transform, d3.zoomIdentity);
            });

            // Process nodes and links
            const nodes = data.nodes.map(n => ({...n, id: n.unique_id}));
            const nodeMap = new Map(nodes.map(n => [n.id, n]));

            const links = data.edges
                .filter(e => nodeMap.has(e.source) && nodeMap.has(e.target))
                .map(e => ({
                    source: e.source,
                    target: e.target
                }));

            // Build adjacency for highlighting and layout
            const upstream = new Map();
            const downstream = new Map();
            nodes.forEach(n => {
                upstream.set(n.id, new Set());
                downstream.set(n.id, new Set());
            });
            links.forEach(l => {
                downstream.get(l.source).add(l.target);
                upstream.get(l.target).add(l.source);
            });

            // Calculate layers using longest path from sources
            function calculateLayers() {
                const layers = new Map();

                function getLongestPath(nodeId, memo = new Map()) {
                    if (memo.has(nodeId)) return memo.get(nodeId);

                    const upstreamNodes = upstream.get(nodeId);
                    if (upstreamNodes.size === 0) {
                        memo.set(nodeId, 0);
                        return 0;
                    }

                    let maxUpstream = 0;
                    upstreamNodes.forEach(upId => {
                        maxUpstream = Math.max(maxUpstream, getLongestPath(upId, memo) + 1);
                    });

                    memo.set(nodeId, maxUpstream);
                    return maxUpstream;
                }

                const memo = new Map();
                nodes.forEach(n => {
                    layers.set(n.id, getLongestPath(n.id, memo));
                });

                return layers;
            }

            const layers = calculateLayers();

            // Group nodes by layer
            const layerGroups = new Map();
            nodes.forEach(n => {
                const layer = layers.get(n.id);
                if (!layerGroups.has(layer)) {
                    layerGroups.set(layer, []);
                }
                layerGroups.get(layer).push(n);
            });

            // Sort layers
            const sortedLayers = Array.from(layerGroups.keys()).sort((a, b) => a - b);

            // Layout parameters
            const nodeWidth = 140;
            const nodeHeight = 50;
            const layerSpacing = 220;
            const nodeSpacing = 80;
            const padding = 100;

            // Calculate positions
            sortedLayers.forEach((layerNum, layerIndex) => {
                const nodesInLayer = layerGroups.get(layerNum);
                const layerHeight = nodesInLayer.length * (nodeHeight + nodeSpacing) - nodeSpacing;
                const startY = (height - layerHeight) / 2;

                nodesInLayer.forEach((node, nodeIndex) => {
                    node.x = padding + layerIndex * layerSpacing;
                    node.y = startY + nodeIndex * (nodeHeight + nodeSpacing);
                });
            });

            // Get all upstream/downstream nodes recursively
            function getAllUpstream(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return visited;
                visited.add(nodeId);
                upstream.get(nodeId)?.forEach(id => getAllUpstream(id, visited));
                return visited;
            }

            function getAllDownstream(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return visited;
                visited.add(nodeId);
                downstream.get(nodeId)?.forEach(id => getAllDownstream(id, visited));
                return visited;
            }

            // Get immediate upstream/downstream (not including self)
            function getUpstreamNodes(nodeId) {
                const result = getAllUpstream(nodeId);
                result.delete(nodeId);
                return result;
            }

            function getDownstreamNodes(nodeId) {
                const result = getAllDownstream(nodeId);
                result.delete(nodeId);
                return result;
            }

            // Create curved link path
            function linkPath(d) {
                const sourceNode = nodeMap.get(typeof d.source === 'object' ? d.source.id : d.source);
                const targetNode = nodeMap.get(typeof d.target === 'object' ? d.target.id : d.target);

                const sx = sourceNode.x + nodeWidth;
                const sy = sourceNode.y + nodeHeight / 2;
                const tx = targetNode.x;
                const ty = targetNode.y + nodeHeight / 2;

                const midX = (sx + tx) / 2;

                return `M ${sx},${sy} C ${midX},${sy} ${midX},${ty} ${tx},${ty}`;
            }

            // Create links
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('path')
                .data(links)
                .enter().append('path')
                .attr('class', 'link')
                .attr('d', linkPath);

            // Create nodes
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Node rectangle
            node.append('rect')
                .attr('width', nodeWidth)
                .attr('height', nodeHeight)
                .attr('rx', 8)
                .attr('ry', 8)
                .attr('fill', d => colors[d.resource_type] || '#888')
                .attr('stroke', d => d3.color(colors[d.resource_type] || '#888').darker(0.5));

            // Node name
            node.append('text')
                .attr('x', nodeWidth / 2)
                .attr('y', nodeHeight / 2 - 2)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .text(d => d.name.length > 16 ? d.name.substring(0, 14) + '...' : d.name);

            // Node type label
            node.append('text')
                .attr('class', 'node-type')
                .attr('x', nodeWidth / 2)
                .attr('y', nodeHeight - 10)
                .attr('text-anchor', 'middle')
                .text(d => d.resource_type);

            // Update visibility based on hidden nodes
            function updateVisibility() {
                node.classed('hidden', d => hiddenNodes.has(d.id));

                link.classed('hidden', l => {
                    const srcId = typeof l.source === 'object' ? l.source.id : l.source;
                    const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
                    return hiddenNodes.has(srcId) || hiddenNodes.has(tgtId);
                });

                // Update hidden badge
                const badge = document.getElementById('hidden-badge');
                if (hiddenNodes.size > 0) {
                    badge.textContent = `${hiddenNodes.size} node${hiddenNodes.size > 1 ? 's' : ''} hidden`;
                    badge.classList.add('visible');
                } else {
                    badge.classList.remove('visible');
                }
            }

            // Collapse/expand functions
            function collapseUpstream(nodeId) {
                const upstreamIds = getUpstreamNodes(nodeId);
                upstreamIds.forEach(id => hiddenNodes.add(id));
                updateVisibility();
            }

            function collapseDownstream(nodeId) {
                const downstreamIds = getDownstreamNodes(nodeId);
                downstreamIds.forEach(id => hiddenNodes.add(id));
                updateVisibility();
            }

            function expandUpstream(nodeId) {
                const upstreamIds = getUpstreamNodes(nodeId);
                upstreamIds.forEach(id => hiddenNodes.delete(id));
                updateVisibility();
            }

            function expandDownstream(nodeId) {
                const downstreamIds = getDownstreamNodes(nodeId);
                downstreamIds.forEach(id => hiddenNodes.delete(id));
                updateVisibility();
            }

            function expandAll() {
                hiddenNodes.clear();
                updateVisibility();
            }

            function focusOnNode(nodeId) {
                // Hide all nodes except this one and its direct connections
                const upstreamIds = getUpstreamNodes(nodeId);
                const downstreamIds = getDownstreamNodes(nodeId);
                const keepVisible = new Set([nodeId, ...upstreamIds, ...downstreamIds]);

                nodes.forEach(n => {
                    if (!keepVisible.has(n.id)) {
                        hiddenNodes.add(n.id);
                    } else {
                        hiddenNodes.delete(n.id);
                    }
                });
                updateVisibility();
            }

            // Expand all button
            document.getElementById('expand-all').addEventListener('click', expandAll);

            // Context menu
            const contextMenu = document.getElementById('context-menu');

            function showContextMenu(event, d) {
                event.preventDefault();
                contextMenuNode = d;

                const upstreamCount = getUpstreamNodes(d.id).size;
                const downstreamCount = getDownstreamNodes(d.id).size;

                // Update menu item text with counts
                document.getElementById('ctx-collapse-upstream').innerHTML =
                    `<span class="context-menu-icon">◀</span><span>Collapse Upstream (${upstreamCount})</span>`;
                document.getElementById('ctx-collapse-downstream').innerHTML =
                    `<span class="context-menu-icon">▶</span><span>Collapse Downstream (${downstreamCount})</span>`;
                document.getElementById('ctx-expand-upstream').innerHTML =
                    `<span class="context-menu-icon">◀</span><span>Expand Upstream (${upstreamCount})</span>`;
                document.getElementById('ctx-expand-downstream').innerHTML =
                    `<span class="context-menu-icon">▶</span><span>Expand Downstream (${downstreamCount})</span>`;

                // Disable if no nodes in that direction
                document.getElementById('ctx-collapse-upstream').classList.toggle('disabled', upstreamCount === 0);
                document.getElementById('ctx-collapse-downstream').classList.toggle('disabled', downstreamCount === 0);
                document.getElementById('ctx-expand-upstream').classList.toggle('disabled', upstreamCount === 0);
                document.getElementById('ctx-expand-downstream').classList.toggle('disabled', downstreamCount === 0);

                contextMenu.style.left = event.clientX + 'px';
                contextMenu.style.top = event.clientY + 'px';
                contextMenu.classList.add('visible');
            }

            function hideContextMenu() {
                contextMenu.classList.remove('visible');
                contextMenuNode = null;
            }

            // Context menu event handlers
            document.getElementById('ctx-collapse-upstream').addEventListener('click', () => {
                if (contextMenuNode) collapseUpstream(contextMenuNode.id);
                hideContextMenu();
            });

            document.getElementById('ctx-collapse-downstream').addEventListener('click', () => {
                if (contextMenuNode) collapseDownstream(contextMenuNode.id);
                hideContextMenu();
            });

            document.getElementById('ctx-expand-upstream').addEventListener('click', () => {
                if (contextMenuNode) expandUpstream(contextMenuNode.id);
                hideContextMenu();
            });

            document.getElementById('ctx-expand-downstream').addEventListener('click', () => {
                if (contextMenuNode) expandDownstream(contextMenuNode.id);
                hideContextMenu();
            });

            document.getElementById('ctx-focus').addEventListener('click', () => {
                if (contextMenuNode) focusOnNode(contextMenuNode.id);
                hideContextMenu();
            });

            // Hide context menu when clicking elsewhere
            document.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });

            // Right-click on nodes
            node.on('contextmenu', function(event, d) {
                showContextMenu(event, d);
            });

            // Hover highlighting
            node.on('mouseenter', function(event, d) {
                if (hiddenNodes.has(d.id)) return;

                const upstreamNodes = getAllUpstream(d.id);
                const downstreamNodes = getAllDownstream(d.id);
                const relevantNodes = new Set([...upstreamNodes, ...downstreamNodes]);

                node.classed('highlighted', n => n.id === d.id)
                    .classed('dimmed', n => !relevantNodes.has(n.id) && !hiddenNodes.has(n.id));

                link.classed('highlighted', l => {
                    const srcId = typeof l.source === 'object' ? l.source.id : l.source;
                    const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
                    return relevantNodes.has(srcId) && relevantNodes.has(tgtId) &&
                           !hiddenNodes.has(srcId) && !hiddenNodes.has(tgtId);
                }).classed('dimmed', l => {
                    const srcId = typeof l.source === 'object' ? l.source.id : l.source;
                    const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
                    if (hiddenNodes.has(srcId) || hiddenNodes.has(tgtId)) return false;
                    return !relevantNodes.has(srcId) || !relevantNodes.has(tgtId);
                });
            });

            node.on('mouseleave', function() {
                node.classed('highlighted', false).classed('dimmed', false);
                link.classed('highlighted', false).classed('dimmed', false);
            });

            // Click to show details
            node.on('click', function(event, d) {
                showDetails(d);
            });

            // Drag functions
            function dragstarted(event, d) {
                d3.select(this).raise();
            }

            function dragged(event, d) {
                d.x = event.x;
                d.y = event.y;
                d3.select(this).attr('transform', `translate(${d.x},${d.y})`);
                link.attr('d', linkPath);
            }

            function dragended(event, d) {
                // Position stays where dropped
            }

            // Search functionality
            const searchInput = document.getElementById('search');
            searchInput.addEventListener('input', function() {
                const query = this.value.toLowerCase();
                if (!query) {
                    node.classed('dimmed', false);
                    link.classed('dimmed', false);
                    return;
                }

                const matchingNodes = new Set();
                nodes.forEach(n => {
                    if (n.name.toLowerCase().includes(query)) {
                        matchingNodes.add(n.id);
                    }
                });

                node.classed('dimmed', n => !matchingNodes.has(n.id) && !hiddenNodes.has(n.id));
                link.classed('dimmed', l => {
                    const srcId = typeof l.source === 'object' ? l.source.id : l.source;
                    const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
                    if (hiddenNodes.has(srcId) || hiddenNodes.has(tgtId)) return false;
                    return !matchingNodes.has(srcId) && !matchingNodes.has(tgtId);
                });
            });

            // Calculate bounding box and center view
            const allX = nodes.map(n => n.x);
            const allY = nodes.map(n => n.y);
            const minX = Math.min(...allX);
            const maxX = Math.max(...allX) + nodeWidth;
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY) + nodeHeight;

            const graphWidth = maxX - minX;
            const graphHeight = maxY - minY;
            const centerX = minX + graphWidth / 2;
            const centerY = minY + graphHeight / 2;

            // Auto-fit the graph in view
            const scale = Math.min(
                (width - 100) / graphWidth,
                (height - 100) / graphHeight,
                1.2
            );
            const translateX = width / 2 - centerX * scale;
            const translateY = height / 2 - centerY * scale;

            svg.call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));

            // Center on a specific node if provided
            if (data.centerNode) {
                const centerNode = nodes.find(n =>
                    n.id === data.centerNode || n.name === data.centerNode
                );
                if (centerNode) {
                    setTimeout(() => {
                        showDetails(centerNode);
                    }, 500);
                }
            }
        }

        function showDetails(node) {
            const panel = document.getElementById('details-panel');
            const content = document.getElementById('details-content');

            const typeColors = {
                model: '#6c63ff',
                source: '#00c9a7',
                seed: '#ffc75f',
                snapshot: '#ff6b6b'
            };

            let columnsHtml = '';
            if (node.columns && Object.keys(node.columns).length > 0) {
                columnsHtml = `
                    <div class="detail-section resizable" id="columns-section">
                        <h3>Columns (${Object.keys(node.columns).length})</h3>
                        <div class="columns-list" id="columns-list">
                            ${Object.values(node.columns).map(col => `
                                <div class="column-item">
                                    <div class="column-header">
                                        <span class="column-name">${col.name}</span>
                                        <div class="column-badges">
                                            ${col.transformation && col.transformation !== 'unknown' ?
                                                `<span class="column-transform transform-${col.transformation}">${col.transformation}</span>` : ''}
                                            ${col.data_type ? `<span class="column-type">${col.data_type}</span>` : ''}
                                        </div>
                                    </div>
                                    ${col.description ? `<div class="column-desc">${col.description}</div>` : ''}
                                    ${col.sources && col.sources.length > 0 ? `
                                        <div class="column-sources">
                                            <span class="sources-label">from:</span>
                                            ${col.sources.map(src => {
                                                const parts = src.split('.');
                                                const colName = parts[parts.length - 1];
                                                const tableName = parts.length > 1 ? parts[parts.length - 2] : '';
                                                return `<span class="source-ref" title="${src}">${tableName ? tableName + '.' : ''}${colName}</span>`;
                                            }).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                        <div class="section-resizer" data-target="columns-list"></div>
                    </div>
                `;
            }

            let tagsHtml = '';
            if (node.tags && node.tags.length > 0) {
                tagsHtml = `
                    <div class="detail-section">
                        <h3>Tags</h3>
                        <div class="tags-list">
                            ${node.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            let sqlHtml = '';
            if (node.raw_sql || node.compiled_sql) {
                // Normalize SQL for comparison (remove whitespace differences)
                const normalizeSQL = (sql) => sql.replace(/\s+/g, ' ').trim().toLowerCase();
                const rawNormalized = normalizeSQL(node.raw_sql || '');
                const compiledNormalized = normalizeSQL(node.compiled_sql || '');
                const sqlsDiffer = rawNormalized && compiledNormalized && rawNormalized !== compiledNormalized;

                let warningHtml = '';
                if (sqlsDiffer) {
                    warningHtml = `
                        <div class="sql-warning">
                            ⚠️ Warning: Raw SQL and compiled SQL differ. The columns shown are based on compiled SQL/catalog.
                        </div>
                    `;
                }

                let sqlTabsHtml = '';
                if (node.raw_sql && node.compiled_sql) {
                    sqlTabsHtml = `
                        <div class="sql-tabs">
                            <button class="sql-tab active" data-tab="raw">Raw SQL</button>
                            <button class="sql-tab" data-tab="compiled">Compiled SQL</button>
                        </div>
                    `;
                }

                const rawSqlHtml = node.raw_sql ? `
                    <pre class="sql-preview" id="sql-preview-raw" style="${node.compiled_sql ? 'display: block;' : ''}">${escapeHtml(node.raw_sql)}</pre>
                ` : '';

                const compiledSqlHtml = node.compiled_sql ? `
                    <pre class="sql-preview" id="sql-preview-compiled" style="${node.raw_sql ? 'display: none;' : ''}">${escapeHtml(node.compiled_sql)}</pre>
                ` : '';

                sqlHtml = `
                    <div class="detail-section resizable" id="sql-section">
                        <h3>SQL</h3>
                        ${warningHtml}
                        ${sqlTabsHtml}
                        ${rawSqlHtml}
                        ${compiledSqlHtml}
                        <div class="section-resizer" data-target="sql-preview-raw"></div>
                    </div>
                `;
            }

            content.innerHTML = `
                <h2>${node.name}</h2>
                <span class="resource-type" style="background: ${typeColors[node.resource_type] || '#888'}">
                    ${node.resource_type}
                </span>

                ${node.description ? `
                    <div class="detail-section">
                        <h3>Description</h3>
                        <p>${node.description}</p>
                    </div>
                ` : ''}

                <div class="detail-section">
                    <h3>Location</h3>
                    <p>
                        <span class="value">${node.database || 'N/A'}</span>.<span class="value">${node.schema || 'N/A'}</span>
                    </p>
                </div>

                ${node.materialized ? `
                    <div class="detail-section">
                        <h3>Materialization</h3>
                        <p><span class="value">${node.materialized}</span></p>
                    </div>
                ` : ''}

                ${node.file_path ? `
                    <div class="detail-section">
                        <h3>File Path</h3>
                        <p><span class="value">${node.file_path}</span></p>
                    </div>
                ` : ''}

                ${tagsHtml}
                ${columnsHtml}
                ${sqlHtml}
            `;

            panel.classList.add('visible');
            document.getElementById('panel-resizer').classList.add('visible');

            // Setup SQL tab switching
            const sqlTabs = document.querySelectorAll('.sql-tab');
            if (sqlTabs.length > 0) {
                sqlTabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const targetTab = e.target.dataset.tab;

                        // Update tab active states
                        sqlTabs.forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');

                        // Show/hide SQL previews
                        const rawPreview = document.getElementById('sql-preview-raw');
                        const compiledPreview = document.getElementById('sql-preview-compiled');

                        if (targetTab === 'raw' && rawPreview) {
                            rawPreview.style.display = 'block';
                            if (compiledPreview) compiledPreview.style.display = 'none';
                        } else if (targetTab === 'compiled' && compiledPreview) {
                            compiledPreview.style.display = 'block';
                            if (rawPreview) rawPreview.style.display = 'none';
                        }
                    });
                });
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Close details panel
        document.getElementById('close-details').addEventListener('click', () => {
            document.getElementById('details-panel').classList.remove('visible');
            document.getElementById('panel-resizer').classList.remove('visible');
        });

        // Panel resizer functionality
        const panelResizer = document.getElementById('panel-resizer');
        const detailsPanel = document.getElementById('details-panel');
        let isResizingPanel = false;

        panelResizer.addEventListener('mousedown', (e) => {
            isResizingPanel = true;
            panelResizer.classList.add('active');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizingPanel) return;

            const containerRect = document.getElementById('container').getBoundingClientRect();
            const newWidth = containerRect.right - e.clientX;

            if (newWidth >= 250 && newWidth <= 800) {
                detailsPanel.style.width = newWidth + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizingPanel) {
                isResizingPanel = false;
                panelResizer.classList.remove('active');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        // Section resizer functionality
        let isResizingSection = false;
        let currentSectionResizer = null;
        let currentTargetElement = null;
        let startY = 0;
        let startHeight = 0;

        document.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('section-resizer')) {
                const targetId = e.target.dataset.target;
                currentTargetElement = document.getElementById(targetId);
                if (!currentTargetElement) return;

                isResizingSection = true;
                currentSectionResizer = e.target;
                startY = e.clientY;
                startHeight = currentTargetElement.offsetHeight;

                currentSectionResizer.classList.add('active');
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizingSection || !currentTargetElement) return;

            const deltaY = e.clientY - startY;
            const newHeight = startHeight + deltaY;

            if (newHeight >= 80 && newHeight <= 600) {
                currentTargetElement.style.height = newHeight + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizingSection) {
                isResizingSection = false;
                if (currentSectionResizer) {
                    currentSectionResizer.classList.remove('active');
                }
                currentSectionResizer = null;
                currentTargetElement = null;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            // Could reinitialize the graph here if needed
        });
    </script>
</body>
</html>
